#include<stdio.h>

#define MAXSIZE 1000//链表的最大长度 
typedef int ElemType;

typedef struct {
	ElemType data;
	int cur;  //游标   为0时表示无指向 
} Component,StaticLinkList[MAXSIZE];

//将一维数组space中各分量链成一备用链表  space[0].cur为头指针 “0”表示空指针 
int InitList(StaticLinkList space) {
	int i;
	for (i = 0; i < MAXSIZE-1; i++) {
		space[i].cur = i+1;
	}
	space[MAXSIZE-1].cur = 0;//目前静态链表为空，最后一个元素的cur为0  
	return 0; 
} 

int ListLength(StaticLinkList L) {
	int j = 0;
	int i = L[MAXSIZE - 1].cur;
	while (i) {
		i = L[i].cur;
		j++;
	}
	return j;
}

//顺序插入静态链表
//若备用链表为空，则返回分配的结点下标，否则返回0 
int Malloc_SLL(StaticLinkList space) {
	int i = space[0].cur;//当前数组的第一个元素得cur存的值  就是要返回第一个备用空闲的下标 
	if (space[0].cur)
	    space[0].cur = space[i].cur;//由于要拿出一个分量来使用了  所以我们把他的下一个分量来做备用 
	return i;
} 

//在L中第i个元素之前插入新的数据元素
int ListInsert(StaticLinkList L, int i, ElemType e) {
	int j, k, l;
	k = MAXSIZE - 1;//k首先是最后一个元素的下标 
	if (i < i || i > ListLength(L) + 1)
	    return 0;
	j = Malloc_SLL(L);
	if (j) {
		L[j].data = e;
		for (l = 1; l <= i-1; l++) {
			k = L[k].cur;
		}
		L[j].cur = L[k].cur;//用头插法插入 
		L[k].cur = j;
		return 1; 
	}
	return 0;
} 

//释放链表元素
void Free_SSL(StaticLinkList space, int i) {
	space[i].cur = space[0].cur;
	space[0].cur = i;
} 
//删除静态链表 
int ListDelete(StaticLinkList L, int i) {
	int j, k;
	if (i < 1 || i > ListLength(L));
	    return 0;
	k = MAXSIZE - 1;
	for (j = 1; j <= i-1; j++) {
		k = L[k].cur;
	} 
	j = L[k].cur;
	L[k].cur = L[j].cur;
	Free_SSL (L, j);
	return 1;
} 

int main() {
	return 0;
} 
